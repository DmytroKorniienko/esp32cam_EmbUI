#include "main.h"
#include "ui.h"
#include "basicui.h"
#include "EmbUI.h"
#include "interface.h"
#include "config.h"

#include "uistrings.h"

/**
 * Define configuration variables and controls handlers
 * variables has literal names and are kept within json-configuration file on flash
 * 
 * Control handlers are bound by literal name with a particular method. This method is invoked
 * by manipulating controls
 * 
 */
void create_parameters(){
    LOG(println, F("Создание конфигурационных переменных по-умолчанию"));
    BasicUI::add_sections();

    //embui->var(FPSTR(P_hostname), "esp32cam", true);        // device hostname (autogenerated on first-run)

    //embui->section_handle_add("esp32camdemo", block_cam);
    embui->section_handle_add("esp32cam", block_cam);
    embui->section_handle_add("stream", block_stream);
    embui->section_handle_add("camSettings", block_cam_settings);

    embui->section_handle_add("ledBtn", led_toggle);
    embui->section_handle_add("ledBright", set_led_bright);
    embui->section_handle_add("refresh", set_refresh);
    embui->section_handle_add("setCam", set_cam);
}

/**
 * This code builds UI section with menu block on the left
 * 
 */
void block_menu(Interface *interf, JsonObject *data){
    if (!interf) return;
    // создаем меню
    interf->json_section_menu();

    interf->option("esp32cam", F("esp32cam"));
    interf->option("stream", F("stream"));
    interf->option("camSettings", F("camSettings"));

    /**
     * добавляем в меню пункт - настройки,
     * это автоматически даст доступ ко всем связанным секциям с интерфейсом для системных настроек
     * 
     */
    BasicUI::opt_setup(interf, data);       // пункт меню "настройки"
    interf->json_section_end();
}

/**
 * Headlile section
 * this is an overriden weak method that builds our WebUI from the top
 * ==
 * Головная секция
 * переопределенный метод фреймфорка, который начинает строить корень нашего WebUI
 * 
 */
void section_main_frame(Interface *interf, JsonObject *data){
    if (!interf) return;

    interf->json_frame_interface("esp32cam");  // HEADLINE for WebUI
    block_menu(interf, data);
    //block_cam(interf, data);
    interf->json_frame_flush();

    if(!embui->sysData.wifi_sta && embui->param(FPSTR(P_WIFIMODE))!="1"){
        // форсируем выбор вкладки настройки WiFi если контроллер не подключен к внешней AP и не задан режим принудительного AP
        BasicUI::block_settings_netw(interf, data);
    } else {
        // главное окно
        block_cam(interf, data);
    }
}

// обработчик кнопки "Переключение светодиода"
void led_toggle(Interface *interf, JsonObject *data){
    if (!interf || !data) return;
    camera->toggleLed();
}

void set_led_bright(Interface *interf, JsonObject *data){
    if (!interf || !data) return;
    SETPARAM("ledBright", camera->setLedBright((*data)["ledBright"].as<int8_t>()));
}

// Check if photo capture was successful
bool checkPhoto( fs::FS &fs ) {
  File f_pic = fs.open( FILE_PHOTO );
  unsigned int pic_sz = f_pic.size();
  return ( pic_sz > 100 );
}

// Capture Photo and Save it to LittleFS
void capturePhotoSaveLittleFS() {
  camera_fb_t * fb = NULL; // pointer
  bool ok = 0; // Boolean indicating if the picture has been taken correctly

  do {
    // Take a photo with the camera
    Serial.println("Taking a photo...");

    fb = esp_camera_fb_get();
    if (!fb) {
      Serial.println("Camera capture failed");
      return;
    }

    // Photo file name
    Serial.printf("Picture file name: %s\n", FILE_PHOTO);
    File file = LittleFS.open(FILE_PHOTO, FILE_WRITE);

    // Insert the data in the photo file
    if (!file) {
      Serial.println("Failed to open file in writing mode");
    }
    else {
      file.write(fb->buf, fb->len); // payload (image), payload length
      Serial.print("The picture has been saved in ");
      Serial.print(FILE_PHOTO);
      Serial.print(" - Size: ");
      Serial.print(fb->len);
      Serial.println(" bytes");
    }
    // Close the file
    file.close();
    esp_camera_fb_return(fb);

    // check if file has been correctly saved in LittleFS
    ok = checkPhoto(LittleFS);
  } while ( !ok );
}

Task *_offtask = nullptr;
void set_refresh(Interface *interf, JsonObject *data)
{
    if(_offtask) return;
    
    camera->setLedBright(7);
    Task *_t = new Task(TASK_SECOND,TASK_ONCE, []{
        capturePhotoSaveLittleFS();
        camera->setLedOffAfterMS(200);
        if(!_offtask){
            _offtask = new Task(TASK_SECOND,TASK_ONCE, []{
                LOG(println, "Update WebUI");
                Interface *interf =  EmbUI::GetInstance()->ws.count()? new Interface(EmbUI::GetInstance(), &EmbUI::GetInstance()->ws, 512) : nullptr;
                if(interf){
                    interf->json_frame_custom("xload");
                    interf->json_section_content();
                    //interf->json_frame_interface();
                    //interf->json_section_begin("photo");
                    //interf->frame2("jpgf", "jpg");
                    //interf->frame2("jpgf", String(FILE_PHOTO) + "?" + micros());
                    interf->image("jpgf", String(FILE_PHOTO) + "?" + micros());
                    interf->json_section_end();
                    interf->json_frame_flush();
                    delete interf;
                }
                _offtask = nullptr;
                TASK_RECYCLE;
            },&ts,true);
            _offtask->enableDelayed();
        } else
            _offtask->restartDelayed();
        TASK_RECYCLE;
    },&ts,true);
    _t->enableDelayed();
}

void block_cam(Interface *interf, JsonObject *data){
    if (!interf) return;

    camera->setLedOff();
    interf->json_frame_interface();
    interf->json_section_main(String("jpg"), String("ESP32CAM"));
    //interf->json_section_begin("photo");
    if(!checkPhoto(LittleFS)){
        camera->setLedBright(7);
        delay(50);
        //interf->frame2("jpgf", "jpg");
        interf->image("jpgf", String(FILE_PHOTO) + "?" + micros());
        camera->setLedOffAfterMS(500);
    } else
        //interf->frame2("jpgf", String(FILE_PHOTO) + "?" + micros());
        interf->image("jpgf", String(FILE_PHOTO) + "?" + micros());
    //interf->json_section_end();
    interf->button("refresh","Обновить");
    interf->json_section_end();
    interf->json_frame_flush();
}

void block_stream(Interface *interf, JsonObject *data){
    if (!interf) return;
    //LOG(println, "Here");

    interf->json_frame_interface();
    interf->json_section_main(String("esp32cam"), String("ESP32CAM STREAM"));

    //interf->raw_html("jpgframe", "<iframe class=\"iframe\" src=\"jpg\"></iframe>"); // marginheight=\"0\" marginwidth=\"0\" width=\"100%\" height=\"100%\" frameborder=\"0\" scrolling=\"yes\"
    interf->iframe("stream", "/camera.html");
    //interf->image("stream", "/stream");
    interf->spacer();
    interf->range("ledBright",String(camera->getLedBright()),String(0),String(15),String(1),"Уровень светимости светодиода", true);
    interf->button("ledBtn","Переключение светодиода");
    
    interf->json_section_hidden(String("setCam"), "Настройки камеры");
    interf->button_submit(String("setCam"), "Сохранить");
    cam_settings(interf, data);
    interf->json_section_end();

    interf->json_section_end();
    interf->json_frame_flush();

    camera->setLedBright(camera->getLedBright());
}

void set_frame(Interface *interf, JsonObject *data) {
    
}

void cam_settings(Interface *interf, JsonObject *data) {

    interf->json_section_line();
    interf->select(FPSTR(T_FRAMESIZE), camera->getParam(FRAMESIZE), String("Разрешение"), false);
    interf->option(String(FRAMESIZE_96X96), "96x96");
    interf->option(String(FRAMESIZE_QQVGA), "160x120");
    interf->option(String(FRAMESIZE_QCIF), "176x144");
    interf->option(String(FRAMESIZE_HQVGA), "240x176");
    interf->option(String(FRAMESIZE_240X240), "240x240");
    interf->option(String(FRAMESIZE_QVGA), "320x240");
    interf->option(String(FRAMESIZE_CIF), "400x296");
    interf->option(String(FRAMESIZE_HVGA), "480x320");
    interf->option(String(FRAMESIZE_VGA), "640x480");
    interf->option(String(FRAMESIZE_SVGA), "800x600");
    interf->option(String(FRAMESIZE_XGA), "1024x768");
    interf->option(String(FRAMESIZE_HD), "1280x720");
    interf->option(String(FRAMESIZE_SXGA), "1280x1024");
    interf->option(String(FRAMESIZE_UXGA), "1600x1200");
#ifdef CAM_3MP
    interf->option(String(FRAMESIZE_FHD), "1920x1080");
    interf->option(String(FRAMESIZE_P_HD), "720x1280");
    interf->option(String(FRAMESIZE_P_3MP), "864x1536");
    interf->option(String(FRAMESIZE_QXGA), "2048x1536");
#endif
#ifdef CAM_5MP
    interf->option(String(FRAMESIZE_QHD), "2560x1440");
    interf->option(String(FRAMESIZE_WQXGA), "2560x1600");
    interf->option(String(FRAMESIZE_P_FHD), "1080x1920");
    interf->option(String(FRAMESIZE_QSXGA), "2560x1920");
#endif
    interf->json_section_end();

    interf->select(FPSTR(T_SPECIAL_EFFECT), camera->getParam(SPECIAL_EFFECT), String("Спец. эффект"), false);
    interf->option(String(0), "Без эффекта");
    interf->option(String(1), "Негатив");
    interf->option(String(2), "Оттенки серого");
    interf->option(String(3), "Красный оттенок");
    interf->option(String(4), "Зеленый оттенок");
    interf->option(String(5), "Синий оттенок");
    interf->option(String(6), "Сепия");
    interf->json_section_end();
    interf->json_section_end();

    interf->json_section_line();
    interf->range(FPSTR(T_QUALITY), camera->getParam(QUALITY), String(0),String(63),String(1),"Качество", false);
    interf->range(FPSTR(T_BRIGHTNESS), camera->getParam(BRIGHTNESS), String(-2),String(2),String(1),"Яркость", false);
    interf->json_section_end();

    interf->json_section_line();
    interf->range(FPSTR(T_CONTRAST), camera->getParam(CONTRAST), String(-2),String(2),String(1),"Контраст", false);
    interf->range(FPSTR(T_SATURATION), camera->getParam(SATURATION), String(-2),String(2),String(1),"Насыщенность", false);
    interf->json_section_end();

    interf->json_section_line();
    interf->range(FPSTR(T_SHARPNESS), camera->getParam(SHARPNESS), String(-2),String(2),String(1),"Острота", false);
    interf->range(FPSTR(T_DENOISE), camera->getParam(DENOISE), String(0),String(63),String(1),"Шумоподавление", false);
    interf->json_section_end();

    interf->json_section_line();
    interf->checkbox(FPSTR(T_AWB), camera->getParam(AWB), "Баланс бел.", false);
    interf->checkbox(FPSTR(T_AWB_GAIN), camera->getParam(AWB_GAIN), "Усиление ББ", false);
    interf->json_section_end();
    interf->select(FPSTR(T_WB_MODE), camera->getParam(WB_MODE), String("Режим ББ"), false);
    interf->option(String(0), "Авто");
    interf->option(String(1), "Солнечно");
    interf->option(String(2), "Облачно");
    interf->option(String(3), "Офис");
    interf->option(String(4), "Дома");
    interf->json_section_end();

    interf->json_section_line();
    interf->checkbox(FPSTR(T_AEC), camera->getParam(AEC), "AEC", false);
    interf->checkbox(FPSTR(T_AEC2), camera->getParam(AEC2), "AEC2", false);
    interf->json_section_end();
    
    interf->json_section_line();
    interf->range(FPSTR(T_AE_LEVEL), camera->getParam(AE_LEVEL), String(-2),String(2),String(1),"AE уровень", false);
    interf->range(FPSTR(T_AEC_VALUE), camera->getParam(AEC_VALUE), String(0),String(1200),String(10),"AEC значение", false);
    interf->json_section_end();

    interf->json_section_line();
    interf->checkbox(FPSTR(T_AGC), camera->getParam(AGC), "AGC", false);
    interf->checkbox(FPSTR(T_BPC), camera->getParam(BPC), "BPC", false);
    interf->checkbox(FPSTR(T_WPC), camera->getParam(WPC), "WPC", false);
    interf->json_section_end();

    interf->json_section_line();
    interf->range(FPSTR(T_AGC_GAIN), camera->getParam(AGC_GAIN), String(0),String(30),String(1),"AGC gain", false);
    interf->range(FPSTR(T_GAINCEILING), camera->getParam(GAINCEILING), String(0),String(6),String(1),"Gainceiling", false);
    interf->json_section_end();

    interf->json_section_line();
    interf->checkbox(FPSTR(T_RAW_GMA), camera->getParam(RAW_GMA), "RAW GMA", false);
    interf->checkbox(FPSTR(T_LENC), camera->getParam(LENC), "LENC", false);
    interf->checkbox(FPSTR(T_HMIRROR), camera->getParam(HMIRROR), "Зеркально", false);
    interf->json_section_end();

    interf->json_section_line();
    interf->checkbox(FPSTR(T_VFLIP), camera->getParam(VFLIP), "Верт. разворот", false);
    interf->checkbox(FPSTR(T_DCW), camera->getParam(DCW), "DCW", false);
    interf->checkbox(FPSTR(T_COLORBAR), camera->getParam(COLORBAR), "Colorbar", false);
    interf->json_section_end();

}

void block_cam_settings(Interface *interf, JsonObject *data) {
    if (!interf) return;
    camera->setLedOff();
    
    interf->json_frame_interface();
    interf->json_section_main(String("camSettings"), String("ESP32CAM SETTINGS"));

    interf->json_section_begin(String("setCam"), "Настройки камеры");
    cam_settings(interf, data);
    interf->button_submit(String("setCam"), "Сохранить");
    interf->json_section_end();
    
    interf->json_section_end();
    interf->json_frame_flush();

}


void set_cam(Interface *interf, JsonObject *data) {

    SETPARAM(FPSTR(T_FRAMESIZE), camera->setParam(FRAMESIZE, (*data)[FPSTR(T_FRAMESIZE)]));
    SETPARAM(FPSTR(T_QUALITY), camera->setParam(QUALITY, (*data)[FPSTR(T_QUALITY)]));
    SETPARAM(FPSTR(T_BRIGHTNESS), camera->setParam(BRIGHTNESS, (*data)[FPSTR(T_BRIGHTNESS)]));
    SETPARAM(FPSTR(T_CONTRAST), camera->setParam(CONTRAST, (*data)[FPSTR(T_CONTRAST)]));
    SETPARAM(FPSTR(T_SATURATION), camera->setParam(SATURATION, (*data)[FPSTR(T_SATURATION)]));
    SETPARAM(FPSTR(T_SHARPNESS), camera->setParam(SHARPNESS, (*data)[FPSTR(T_SHARPNESS)]));
    SETPARAM(FPSTR(T_DENOISE), camera->setParam(DENOISE, (*data)[FPSTR(T_DENOISE)]));
    SETPARAM(FPSTR(T_SPECIAL_EFFECT), camera->setParam(SPECIAL_EFFECT, (*data)[FPSTR(T_SPECIAL_EFFECT)]));
    SETPARAM(FPSTR(T_WB_MODE), camera->setParam(WB_MODE, (*data)[FPSTR(T_WB_MODE)]));
    SETPARAM(FPSTR(T_AWB), camera->setParam(AWB, (*data)[FPSTR(T_AWB)]));
    SETPARAM(FPSTR(T_AWB_GAIN), camera->setParam(AWB_GAIN, (*data)[FPSTR(T_AWB_GAIN)]));
    SETPARAM(FPSTR(T_AEC), camera->setParam(AEC, (*data)[FPSTR(T_AEC)]));
    SETPARAM(FPSTR(T_AEC2), camera->setParam(AEC2, (*data)[FPSTR(T_AEC2)]));
    SETPARAM(FPSTR(T_AE_LEVEL), camera->setParam(AE_LEVEL, (*data)[FPSTR(T_AE_LEVEL)]));
    SETPARAM(FPSTR(T_AEC_VALUE), camera->setParam(AEC_VALUE, (*data)[FPSTR(T_AEC_VALUE)]));
    SETPARAM(FPSTR(T_AGC), camera->setParam(AGC, (*data)[FPSTR(T_AGC)]));
    SETPARAM(FPSTR(T_AGC_GAIN), camera->setParam(AGC_GAIN, (*data)[FPSTR(T_AGC_GAIN)]));
    SETPARAM(FPSTR(T_GAINCEILING), camera->setParam(GAINCEILING, (*data)[FPSTR(T_GAINCEILING)]));
    SETPARAM(FPSTR(T_BPC), camera->setParam(BPC, (*data)[FPSTR(T_BPC)]));
    SETPARAM(FPSTR(T_WPC), camera->setParam(WPC, (*data)[FPSTR(T_WPC)]));
    SETPARAM(FPSTR(T_RAW_GMA), camera->setParam(RAW_GMA, (*data)[FPSTR(T_RAW_GMA)]));
    SETPARAM(FPSTR(T_LENC), camera->setParam(LENC, (*data)[FPSTR(T_LENC)]));
    SETPARAM(FPSTR(T_HMIRROR), camera->setParam(HMIRROR, (*data)[FPSTR(T_HMIRROR)]));
    SETPARAM(FPSTR(T_VFLIP), camera->setParam(VFLIP, (*data)[FPSTR(T_VFLIP)]));
    SETPARAM(FPSTR(T_DCW), camera->setParam(DCW, (*data)[FPSTR(T_DCW)]));
    SETPARAM(FPSTR(T_COLORBAR), camera->setParam(COLORBAR, (*data)[FPSTR(T_COLORBAR)]));
}

void pubCallback(Interface *interf){
    if (!interf) return;
    interf->json_frame_value();
    interf->value(F("pTime"), embui->timeProcessor.getFormattedShortTime(), true);
    interf->value(F("pMem"), String(ESP.getFreeHeap())+F(" / ")+String(ESP.getFreePsram()), true);
    //interf->value(F("pUptime"), String(embui->getUptime()), true);
    char fuptime[16];
    uint32_t tm = embui->getUptime();
    sprintf_P(fuptime, PSTR("%u.%02u:%02u:%02u"),tm/86400,(tm/3600)%24,(tm/60)%60,tm%60);
    interf->value("pUptime", String(fuptime), true);
    //interf->value("fsfreespace", String(myLamp.getLampState().fsfreespace), true);
    int32_t rssi = WiFi.RSSI();
    interf->value("pRSSI", String(constrain(map(rssi, -85, -40, 0, 100),0,100)) + F("% (") + String(rssi) + F("dBm)"), true);
    interf->json_frame_flush();
}
